package main

import (
	"fmt"
	"os"
	"strings"

	"gopkg.in/src-d/go-git.v4"
	"gopkg.in/src-d/go-git.v4/plumbing/object"
)

func GenerateHeader(dir string) {
	fmt.Println("/**")
	fmt.Println("* gogitvers.h: file containing version identification constants")
	fmt.Println("* ")
	fmt.Println("* THIS FILE HAS BEEN AUTOMATICALLY GENERATOR, PLEASE DO NOT MODIFY")
	fmt.Println("* Generated by GoGitVers, visit https://github.com/thew44/gogitvers")
	fmt.Println("* Mathieu ALLORY (c) 2020, Under MIT license.")
	fmt.Println("*/")
	fmt.Println()
	fmt.Println("// Source repository path: " + dir)
	fmt.Println()
}

func GenerateBody(hash string, commit_id int, has_changes bool) {
	fmt.Printf("#define GGVERS_HASH            \"%s\"\n", hash)
	fmt.Printf("#define GVGERS_COMMIT_ID       %d\n", commit_id)

	if has_changes == true {
		fmt.Printf("#define GVGERS_UNCOMMITTED     1\n")
	} else {
		fmt.Printf("#define GVGERS_UNCOMMITTED     0\n")
	}

	fmt.Printf("#define GGVERS_FULL_VERSION    \"Commit %d, Hash %s, Unclean:%t\"\n", commit_id, hash, has_changes)
}

func CheckIfError(err error) {
	if err == nil {
		return
	}

	fmt.Printf("\x1b[31;1m%s\x1b[0m\n", fmt.Sprintf("error: %s", err))
	os.Exit(1)
}

func CheckArgs(arg ...string) {
	if len(os.Args) < len(arg)+1 {
		fmt.Printf("\x1b[36;1m%s\x1b[0m\n", fmt.Sprintf("Usage: %s %s", os.Args[0], strings.Join(arg, " ")))
		os.Exit(1)
	}
}

func main() {
	var hash_str string
	CheckArgs("<directory>")
	directory := os.Args[1]
	GenerateHeader(directory)

	// Opens an already existing repository.
	repo, err := git.PlainOpen(directory)
	CheckIfError(err)

	ref, err := repo.Head()
	CheckIfError(err)

	// Get hash
	commit, err := repo.CommitObject(ref.Hash())
	CheckIfError(err)

	for i := 0; i <= 3; i++ {
		hash_str += fmt.Sprintf("%x", commit.Hash[i])
	}

	// Calculate commit_id: the number of commits in the tree
	cIter, err := repo.Log(&git.LogOptions{
		From: ref.Hash(),
	})
	CheckIfError(err)

	count_commits := 0
	err = cIter.ForEach(func(c *object.Commit) error {
		count_commits++
		return nil
	})

	// Check whether there are uncommited changes
	wktree, err := repo.Worktree()
	CheckIfError(err)
	status, err := wktree.Status()
	CheckIfError(err)

	GenerateBody(hash_str, count_commits, status.IsClean())
}
