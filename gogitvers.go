package main

import (
	"fmt"
	"os"
	"os/exec"
	"time"

	"gopkg.in/src-d/go-git.v4"
	"gopkg.in/src-d/go-git.v4/plumbing/object"
)

/* global variable declaration */
var gForce bool

func generateHeader(dir string) {
	fmt.Println("/**")
	fmt.Println("* gogitvers.h: file containing version identification constants")
	fmt.Println("* ")
	fmt.Println("* THIS FILE HAS BEEN AUTOMATICALLY GENERATED, PLEASE DO NOT MODIFY")
	fmt.Println("* Generated by gogitvers, visit https://github.com/thew44/gogitvers")
	fmt.Println("* Mathieu ALLORY (c) 2020, Under MIT license.")
	fmt.Println("*/")
	fmt.Println()
	fmt.Println("// Generated on: " + time.Now().String())
	if dir != "" {
		fmt.Println("// Source repository path: " + dir)
		fmt.Println()
	}
}

func generateError(err string) {
	if gForce {
		fmt.Println("// ERROR: " + err)
		fmt.Println()
		generateBody("UNKNOWN", 0, false, false)
	} else {
		fmt.Println("#error gogitvers: " + err)
		fmt.Println()
	}
}

func generateWarning(err string) {
	fmt.Println("// WARNING: " + err)
	fmt.Println()
}

func generateBody(hash string, commitID int, statusIsKnown bool, isClean bool) {
	// Repo identification
	fmt.Printf("#define GGVERS_HASH            \"%s\"\n", hash)
	fmt.Printf("#define GVGERS_COMMIT_ID       %d\n", commitID)

	// Repo cleanliness
	var cleanliness string
	if statusIsKnown == true && isClean == true {
		fmt.Printf("#define GVGERS_ISDIRTY         0\n")
		cleanliness = "Clean"
	} else if statusIsKnown == true && isClean == false {
		fmt.Printf("#define GVGERS_ISDIRTY         1\n")
		cleanliness = "Dirty"
	} else {
		fmt.Printf("#define GVGERS_ISDIRTY         2\n")
		cleanliness = "Unknown"
	}

	// Build identification
	fmt.Println()
	fmt.Printf("#if defined(_DEBUG) || defined (QT_DEBUG)\n")
	fmt.Printf("# define GVGERS_DEBUG        1\n")
	fmt.Printf("# define GGVERS_FULL_VERSION    \"Commit %d, Hash %s, State:%s,DEBUG\"\n", commitID, hash, cleanliness)
	fmt.Printf("#else\n")
	fmt.Printf("# define GVGERS_DEBUG        0\n")
	fmt.Printf("# define GGVERS_FULL_VERSION    \"Commit %d, Hash %s, State:%s\"\n", commitID, hash, cleanliness)
	fmt.Printf("#endif\n")
}

func checkIfError(err error) {
	if err == nil {
		return
	}

	generateError(fmt.Sprintf("%s", err))
	os.Exit(1)
}

func main() {
	// Check arguments
	if len(os.Args) < 2 {
		generateHeader("")
		generateError(fmt.Sprintf("Usage: %s <directory> [-f]", os.Args[0]))
		os.Exit(1)
	}
	directory := os.Args[1]
	gForce = false
	if len(os.Args) > 2 {
		if os.Args[2] == "-f" {
			gForce = true
		}
	}

	// Print header
	generateHeader(directory)

	// Opens an already existing repository.
	repo, err := git.PlainOpen(directory)
	checkIfError(err)

	ref, err := repo.Head()
	checkIfError(err)

	// Get hash
	commit, err := repo.CommitObject(ref.Hash())
	checkIfError(err)
	var hashStr string
	for i := 0; i <= 3; i++ {
		hashStr += fmt.Sprintf("%x", commit.Hash[i])
	}

	// Calculate commit_id: the number of commits in the tree
	cIter, err := repo.Log(&git.LogOptions{
		From: ref.Hash(),
	})
	checkIfError(err)

	countCommits := 0
	err = cIter.ForEach(func(c *object.Commit) error {
		countCommits++
		return nil
	})

	// Check whether there are uncommitted changes (dirty repo)
	// I tried repo.Worktree() then wktree.Status() but first
	// it is very slow, second it does not work when a file is locked
	// (for instance, when a solution is opened with VC++ :-) and third...
	// I always get "true" as an answer to the question.
	// So in use the external git command which must be in the path.
	// Still, this is not blocking if it does not work
	var stateRepoKnown bool
	var stateRepoClean bool
	cmd := exec.Command("git", "status", "--porcelain")
	cmd.Dir = directory
	out, err := cmd.Output()
	if err != nil {
		// Unfortunately, we could not execute the command
		generateWarning(fmt.Sprintf("Could not check whether repo is clean (git error): %s", err))
		stateRepoKnown = false
		stateRepoClean = false
	} else {
		stateRepoKnown = true
		if len(out) == 0 {
			stateRepoClean = true
		} else {
			stateRepoClean = false
		}
	}

	generateBody(hashStr, countCommits, stateRepoKnown, stateRepoClean)
}
