package main

import (
	"fmt"
	"os"
	"time"

	"gopkg.in/src-d/go-git.v4"
	"gopkg.in/src-d/go-git.v4/plumbing/object"
)

/* global variable declaration */
var gForce bool

func generateHeader(dir string) {
	fmt.Println("/**")
	fmt.Println("* gogitvers.h: file containing version identification constants")
	fmt.Println("* ")
	fmt.Println("* THIS FILE HAS BEEN AUTOMATICALLY GENERATED, PLEASE DO NOT MODIFY")
	fmt.Println("* Generated by GoGitVers, visit https://github.com/thew44/gogitvers")
	fmt.Println("* Mathieu ALLORY (c) 2020, Under MIT license.")
	fmt.Println("*/")
	fmt.Println()
	fmt.Println("// Generated on: " + time.Now().String())
	if dir != "" {
		fmt.Println("// Source repository path: " + dir)
		fmt.Println()
	}
}

func generateError(err string) {
	if gForce {
		fmt.Println("// ERROR: " + err)
		fmt.Println()
		generateBody("UNKNOWN", 0, false)
	} else {
		fmt.Println("#error gogitvers: " + err)
		fmt.Println()
	}
}

func generateBody(hash string, commitID int, hasChanges bool) {
	fmt.Printf("#define GGVERS_HASH            \"%s\"\n", hash)
	fmt.Printf("#define GVGERS_COMMIT_ID       %d\n", commitID)

	if hasChanges == true {
		fmt.Printf("#define GVGERS_UNCOMMITTED     1\n")
	} else {
		fmt.Printf("#define GVGERS_UNCOMMITTED     0\n")
	}

	fmt.Printf("#define GGVERS_FULL_VERSION    \"Commit %d, Hash %s, Clean:%t\"\n", commitID, hash, !hasChanges)
}

func checkIfError(err error) {
	if err == nil {
		return
	}

	generateError(fmt.Sprintf("%s", err))
	os.Exit(1)
}

func main() {
	// Check arguments
	if len(os.Args) < 2 {
		generateHeader("")
		generateError(fmt.Sprintf("Usage: %s <directory> [-f]", os.Args[0]))
		os.Exit(1)
	}
	directory := os.Args[1]
	gForce = false
	if len(os.Args) > 2 {
		if os.Args[2] == "-f" {
			gForce = true
		}
	}

	// Print header
	generateHeader(directory)

	// Opens an already existing repository.
	repo, err := git.PlainOpen(directory)
	checkIfError(err)

	ref, err := repo.Head()
	checkIfError(err)

	// Get hash
	commit, err := repo.CommitObject(ref.Hash())
	checkIfError(err)
	var hashStr string
	for i := 0; i <= 3; i++ {
		hashStr += fmt.Sprintf("%x", commit.Hash[i])
	}

	// Calculate commit_id: the number of commits in the tree
	cIter, err := repo.Log(&git.LogOptions{
		From: ref.Hash(),
	})
	checkIfError(err)

	countCommits := 0
	err = cIter.ForEach(func(c *object.Commit) error {
		countCommits++
		return nil
	})

	// Check whether there are uncommited changes
	wktree, err := repo.Worktree()
	checkIfError(err)
	status, err := wktree.Status()
	checkIfError(err)

	generateBody(hashStr, countCommits, status.IsClean())
}
